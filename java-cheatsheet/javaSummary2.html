<div class="row" id="javaDiv">
  <div class="col s12 m12 l12">
    <div class="card-panel white">
      <h1>Java Cheat Sheet </h1>

      <a class="waves-effect waves-light btn" id="keywordButton">Show</a>
      <h3> Intro </h3>
        <p> This section quickly summarizes some major Java concepts. Each section has a short introductory paragraph,
          followed by bullet points with what I believe to be the key ideas. It is assumed the reader is familiar with
          these concepts, as the purpose is to refresh the mind of the reader rather than teach them new material. </p>

        <p id="note-aside"> Note: To help with remembering, some keywords will be hidden. Simply click or tap the box 
        to reveal the important keyword(s). Disable/Enable all the hidden words by tapping the button at the top right. 
        </p>


        <div class="chip example-chip">Example</div>
        <pre class="prettyprint">There are <span class="answer">eight</span> bits in a byte. </pre>

      <h3> General </h3>
        <p> Java is an Object-Oriented Programming (OOP) language, that is <span class="answer">statically</span> 
          scoped, and <span class="answer">statically</span> typed. </p>

        <h5> Java Platform </h5>
          <p> All programs written in the Java language rely on the set of predefined classes that comprise the Java 
            platform. Java classes are organized into related groups known as packages. The Java platform defines 
            packages for functionality such as input/output, networking, graphics, user-interface creation, security, 
            and much more. (Source page 2 java in a nutshell) </p>


      <h3> Types </h3>
        <p>Java has eight primitive types: </p>
        <table class="striped">
          <thead>
            <tr>
                <th data-field="type">Type</th>
                <th data-field="bits">Bit Depth (bits)</th>
                <th data-field="value-range">Value Range</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>byte</td>
              <td>8</td>
              <td>-128 to 127</td>
            </tr>
            <tr>
              <td>short</td>
              <td>16</td>
              <td>-32,768 to 32767</td>
            </tr>
            <tr>
              <td>int</td>
              <td>32</td>
              <td>~ +/- 2.1 Million</td>
            </tr>
            <tr>
              <td>long</td>
              <td>64</td>
              <td>-2<sup>63</sup> to 2<sup>63</sup> -1</td>
            </tr>
            <tr>
              <td>float</td>
              <td>32</td>
              <td>varies</td>
            </tr>
            <tr>
              <td>double</td>
              <td>64</td>
              <td>varies</td>
            </tr>
            <tr>
              <td>char</td>
              <td>16</td>
              <td>0 to 65,535</td>
            </tr>
            <tr>
              <td>boolean</td>
              <td>jvm-specific</td>
              <td>true or false</td>
            </tr>

          </tbody>
        </table>

        <p>Notice how all the primitive numbers are signed, and are bounded by -2<sup>n</sup> to 2<sup>n</sup> -1,
          where n is the number of bits.</p>
        
        <h4> Strings </h4>
        <p>In Java, Strings are a sequence of characters. They are objects, and the String class provides many methods
          to manipulate them.</p>

        <ul class="java-lists">
          <li>Strings in Java are <span class="answer">immutable</span> for:
            <ul class="java-lists">
              <li>Security reasons.</li>
              <li>Synchronization.</li>
              <li>Caching.</li>
              <li>Class Loading.</li>
            </ul>
          </li>
          <li>Java provides the String class, to allow for:
            <ul>
              <li>String concatenation: <pre class="prettyprint">String str = str1.concat(str2);</pre></li>
              <li>String subString: <pre class="prettyprint">String subOfS1 = str1.length(int start, int end);</pre></li>
              <li>String formatting: <pre class="prettyprint">String str = String.format("Hello %s", "Batman");</pre></li>
              <li>And many more methods, such as:
                <ul class="java-lists">
                  <li>charAt(int index)</li>
                  <li>contains(CharSequence s)</li>
                  <li>equals(Object object)</li>
                  <li>indexOf([many options])</li>
                  <li>isEmpty()</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">Click Here </a> to see all of them by seeing the official documentation.</p>

        <h5>String vs StringBuffer vs StringReader </h5>
          <p>Since Strings are immutable, it could be more efficient to use StringBuilder/StringBuffer (which are 
            mutable. As of Java 5.0, you should use StringBuilder instead of StringBuffer, unless you need your String manipulations to be threadsafe. I'd argue that only when dealing with big data would this be necessary, and to usually just use String. Since StringBuilder is mutable, there are some methods that could be of use, like:</p>

          <ul class="java-lists">
            <li>StringBuilder delete(int start, int end)</li>
            <li>StringBuilder reverse()</li>
            <li>StringBuilder replace(int start, int end, String s)</li>
            <li>void setCharAt(int index, char ch)</li>
          </ul>

          <p>Below is a simple table to distinguish the differences between the three:</p>

          <table class="striped" id="types-table">
            <thead>
              <tr>
                  <th data-field="s-blank"></th>
                  <th data-field="s-standard">String</th>
                  <th data-field="sbuffer">StringBuffer</th>
                  <th data-field="sbuilder">StringBuilder</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><span class="table-header">Storage Area</span> </td>
                <td>Constant String Pool</td>
                <td>Heap</td>
                <td>Heap</td>
              </tr>
              <tr>
                <td><span class="table-header">Modifiable</span> </td>
                <td>Immutable</td>
                <td>Mutable</td>
                <td>Mutable</td>
              </tr>
              <tr>
                <td><span class="table-header">Thread Safe</span> </td>              
                <td>Yes</td>
                <td>Yes</td>
                <td>No</td>
              </tr>
              <tr>
                <td><span class="table-header">Performance</span> </td>              
                <td>Fast</td>
                <td>"Very" Slow</td>
                <td>Fast</td>
              </tr>
            </tbody>
          </table>






      <h3 class="java-inline-header">Inheritance </h3><h5 class="java-inline-header"> (subclass) vs </h5> 
        <h3 class="java-inline-header">Polymorphism </h3> <h5 class="java-inline-header">(subtype)</h5>
        <p>Inheritance (<span class="answer">subclassing</span>) is the process where one class 
          acquires the properties (methods and instance variables) of another by <span class="terminology">extending
          </span> it. Polymorphism (<span class="answer">subtyping</span>) is the ability to use subtypes in place of 
          supertypes. Subclassing is both <span class="answer">inheritance</span> + <span class="answer"> subtyping 
          </span>. </p>

        <p><strong>Inheritance</strong> </p>
          <ul class="java-lists">
            <li>Allows for code reuse. </li>   
            <li>Can't get inheritance without <span class="answer">subtyping</span>. </li>
            <li><span class="answer">IS-A</span> Relationship. </li>
          </ul>
          <div class="chip example-chip"> Example </div>
          <p><span class="code-snippet">class Dog extends Animal</span> will acquire all methods and instance variables 
            of <span class="code-snippet">Animal</span>. <span class="code-snippet">Dog</span> <span class="answer">
            IS-A</span> <span class="code-snippet">Animal</span>. </p>

        <p><strong>Polymorphism</strong></p>
          <ul class="java-lists">
            <li>Literally translate to <span class="answer">having many forms</span>.</li>
            <li>When you define a supertype for a group of classes, <strong> any subclass of that supertype can be 
              substituted where the supertype is expected</strong>.</li>
            <li>Can be considered a subclass.</li>
            <li>Allows for polymorphic arrays! </li>
            <li>Allows for polymorphic arguments and return types! </li>
          </ul>
          <div class="chip example-chip"> Example </div>
          <span id="note-aside">Note: Assuming classes Dog, Hamster, and arcticWolf extend Animal: </span>
          <pre class="prettyprint">Animal myAnimal = new Dog() || new Hamster() || new arcticWolf();</pre>

      <h3>Override vs Overload</h3>
        <p>Most people seem to confuse these two, but they have nothing in common. Overriding occurs when a class inherits
          a method, and there is a need for the method to perform differently, so the method is overriden, and it then uses
          the new method rather than the inherited one. Oerloading is having two or more methods with the same name that 
          take a different number of parameters, or different type(s) of paramaters. </p>

        <p><strong>Overriding </strong> </p>
          <ul class="java-lists">
            <li> When a derived class requires a <span class="answer">different definition</span> of an inherited method.</li>
            <li> <span class="answer">Arguments</span> and <span class="answer">return</span> must be the same. </li>
            <li> Method can't be less accessible.</li>
          </ul>
        <p><strong> Overloading </strong></p>
          <ul class="java-lists">
            <li>Same method name, but either different number of <span class="answer">arguments</span>, or 
              <span class="answer">different types of arguments</span>.</li>
            <li> Has nothing to do with inheritance or <span class="answer">polymorphism</span>.</li>
            <li> Just changing the return type will cause <span class="answer">an error</span> and is NOT overloading.</li>
          </ul>

      <h3> Big-O notation, and algorithm complexity </h3>
        <span id="note-aside">Note: UNDER CONSTRUCTION</span>
        <p>Big-O is what we use to derive how long an algorithm takes to run. Big-O is how quickly it grows relative to the
          input, as the input gets arbitrarily large. <a href="http://bigocheatsheet.com/">Click here </a> for an excellent 
          resource that breaks down many sorting algorithms as well as data structure, heap and graph operations into best, 
          average and worst space and time complexity. </p>
        <img class="responsive-img" src="img/big-o-complexity.png">

      <br>
      <h3 class="java-inline-header"> Sorting Algorithms runtime</h3> <h5 class="java-inline-header">
        (see link in above section) </h5>
        <p><span id="note-aside">Note: UNDER CONSTRUCTION</span></p>
        <p>To be completed + data structures: tree, arraylist, array, stack, dictionary, map (hashmap, hashtree)</p> 

      <h3> Exceptions and Errors </h3>
        <span id="note-aside">Note: UNDER CONSTRUCTION</span>
        <p>If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception</p>
        <p>Checked Exceptions</p>
          <ul class="java-lists">
            <li>extend Exceptions for this </li>
            <li>Give us reliable checked documentation about which exceptions might be thrown, and therefore
              which exceptions definitely will not be thrown!</li>
            <li>if method has checked exception in signature, try catch is not necessary</li>
          </ul>

        <p>Unchecked Exceptions</p>
          <ul class="java-lists">
            <li>extend runtime exceptions for this</li>
          </ul>
    </div>
  </div>
</div>