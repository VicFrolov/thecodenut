<div id="index-banner" class="section no-pad-bot">
  <div id="content" class="container">
    <h1>Java Cheat Sheet </h1>
    <input type="button" value="Show/Hide Keywords" id="keywordButton">
    <hr>
    <h2> Intro </h2>
      <p> This section quickly summarizes some major Java concepts. Each section has a short introductory paragraph,
        followed by bullet points with what I believe to be the key ideas. It is assumed the reader is familiar with
        these concepts, as the purpose is to refresh the mind of the reader rather than teach them new material. </p>

      <p> To help with remembering, some keywords will be hidden. Simply click or tap the box to reveal the
        important keyword(s). e.g. There are <span class="answer">eight</span> bits in a byte. Disable/Enable all the 
        hidden words by tapping the button at the top right. </p>

    <hr>

    <h2> General </h2>
      <p> Java is an Object-Oriented Programming (OOP) language, that is <span class="answer">statically</span> 
        scoped, and <span class="answer">statically</span> typed. </p>

      <h4> Java Platform </h4>
        <p> All programs written in the Java language rely on the set of predefined classes that comprise the Java 
          platform. Java classes are organized into related groups known as packages. The Java platform defines 
          packages for functionality such as input/output, networking, graphics, user-interface creation, security, 
          and much more. (Source page 2 java in a nutshell) </p>

    <hr>

    <h2>Inheritance (subclass) vs Polymorphism (subtype)</h2>
      <p>Inheritance (<span class="answer">subclassing</span>) is the process where one class 
        acquires the properties (methods and instance variables) of another by <span class="terminology">extending
        </span> it. Polymorphism (<span class="answer">subtyping</span>) is the ability to use subtypes in place of 
        supertypes. Subclassing is both <span class="answer">inheritance</span> + <span class="answer"> subtyping 
        </span>. </p>

      <p><strong>Inheritance</strong></p>
        <ul>
          <li>Allows for code reuse.</li>   
          <li>Can't get inheritance without <span class="answer">subtyping</span>.</li>
          <li><span class="answer">IS-A</span> Relationship.</li>
          <li>EXAMPLE: <pre> class Dog extends Animal </pre> will acquire all methods and instance variables of 
            <pre>Animal. Dog</pre> <span class="terminology"> IS-A </span> <pre>Animal</pre>. </li>
        </ul>

      <p><strong>Polymorphism</strong></p>
        <ul>
          <li>Literaly translate to <span class="answer">having many forms</span>.</li>
          <li>When you define a supertype for a group of classes, <strong> any subclass of that supertype can be 
            substituted where the supertype is expected</strong>.</li>
          <li>Can be considered a subclass. EXAMPLE: Animal myAnimal = new Dog() || new Cat().</li>
          <li>Allows for polymorphic arrays! </li>
          <li>Allows for polymorphic arguments and return types! </li>
        </ul>

    <hr>

    <h2>Override vs Overload</h2>
      <p>Most people seem to confuse these two, but they have nothing in common. Overriding occurs when a class inherits
        a method, and there is a need for the method to perform differently, so the method is overriden, and it then uses
        the new method rather than the inherited one. Oerloading is having two or more methods with the same name that 
        take a different number of parameters, or different type(s) of paramaters. </p>

      <p><strong>Overriding </strong> </p>
        <ul>
          <li> When a derived class requires a <span class="answer">different definition</span> of an inherited method.</li>
          <li> <span class="answer">Arguments</span> and <span class="answer">return</span> must be the same. </li>
          <li> Method can't be less accessible.</li>
        </ul>
      <p><strong> Overloading </strong></p>
        <ul>
          <li>Same method name, but either different number of <span class="answer">arguments</span>, or 
            <span class="answer">different types of arguments</span>.</li>
          <li> Has nothing to do with inheritance or <span class="answer">polymorphism</span>.</li>
          <li> Just changing the return type will cause <span class="answer">an error</span> and is NOT overloading.</li>
        </ul>

    <hr>

    <h2> Big-O notation, and algorithm complexity </h2>
      <p>Big-O is what we use to derive how long an algorithm takes to run. Big-O is how quickly it grows relative to the
        input, as the input gets arbitrarily large. <a href="http://bigocheatsheet.com/">Click here </a> for an excellent 
        resource that breaks down many sorting algorithms as well as data structure, heap and graph operations into best, 
        average and worst space and time complexity. </p>
      <img src="img/big-o-complexity.png"/> 
      <h3> Sorting Algorithms runtime (seen in more detail on link above) </h3>
        <p>To be completed + data structures: tree, arraylist, array, stack, dictionary, map (hashmap, hashtree)</p> 

    <hr>

    <h2> Exceptions and Errors </h2>
      <p>If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception</p>
      <p>Checked Exceptions</p>
        <ul>
          <li>extend Exceptions for this </li>
          <li>Give us reliable checked documentation about which exceptions might be thrown, and therefore
            which exceptions definitely will not be thrown!</li>
          <li>if method has checked exception in signature, try catch is not necessary</li>
        </ul>

      <p>Unchecked Exceptions</p>
        <ul>
          <li>extend runtime exceptions for this</li>
        </ul>
  </div>
</div>

<script type="text/javascript" src="../js/custom.js"></script>
